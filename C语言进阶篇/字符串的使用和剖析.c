#include <stdio.h>
#include <assert.h>

//==================================strlen=====================================

//以'\0'为结束标志
//返回值是无符号的

//==================================strcpy=====================================
//(拷贝（替换）)

//源字符串必须以'\0'结束
//会将源字符串中的'\0'拷贝到目标空间
//目标空间必须足够大, 源字符串要能放的下
//目标必须可修改

//==================================strcat=====================================
//(字符串链接)

//源字符串必须以'\0'结束
//目标空间必须足够大, 源字符串要能放的下
//目标必须可修改

//模拟strcat

//char* my_strcat(char* dest, const char* src)
//{
//	assert(dest && src);
//	char* ret = dest;
//	while (*dest != '\0')
//	{
//		dest++;
//	}
//	while (*dest++ = *src++) //由此如果自己加自己就会死循环
//	{
//		;
//	}
//	return ret;
//}
//
//int main()
//{
//	char arr1[30] = "hello";
//	char arr2[] = "world";
//	my_strcat(arr1, arr2);
//	printf("%s\n", arr1);
//
//	return 0;
//}

//==================================strcmp==================================
//(比较两个字符串)

//比较的不是个数，比较的是ASCLL码
//大于返回 正数，等于返回0，小于返回 负数

//==========================strncmp,strncpy,strncat=========================
//有字符个数限制，第三个参数是个数

//int main()
//{
//	char arr1[10] = " abcdefgh";
//	char arr2[] = "bit";
//
//	//strncpy(arr1, arr2, 6); //个数为几就拷贝几个，源字符串不够，用\0继续拷贝
//
//	strncat(arr1, arr2, 3); //追加完了还加上\0，源函数不够，只要追加到了\0就不用继续追加了
//	printf("%s\n",arr1);
//
//
//	return 0;
//}

//====================================strstr======================================
//查找字符串，找到返回第一次出现的地址，找不到返回空指针NULL

//char* my_strstr(const char* p1, const char* p2)
//{
//	assert(p1 != NULL);
//	assert(p2 != NULL);
//	char* s1 = p1;
//	char* s2 = p2;
//	char* cur = p1;
//
//	if (*p2 == '\0')
//	{
//		return p1;
//	}
//	while (*cur)
//	{
//		s1 = cur;
//		s2 = p2;
//		while ((*s1 != '\0') && (*s2 != '\0') && (*s1 == *s2))
//		{
//			s1++;
//			s2++;
//		}
//		if (*s2 == '\0')
//		{
//			return cur;
//		}
//	cur++;
//	}
//	return NULL;
//}
//
//
//int main()
//{
//	char* p1 = "abcdef";
//	char* p2 = "def";
//
//	char* ret = my_strstr(p1,p2);
//
//	if (ret == NULL)
//	{
//		printf("子串不存在\n");
//	}
//	else
//	{
//		printf("%s\n", ret);
//	}
//
//	return 0;
//}

//=======================================strtok=======================================
//根据某个源字符串分割目标字符串

//会把找到的分割符直接替换成 '\0',并返回开头寻找的地址
//分割后要继续寻找剩下的需要再次调用函数，但是第一个形参此时需要为NULL，由此也可以看出函数内部有静态变量

//int main()
//{
//	char arr[] = "123@234 . @234";
//	char* p = "@.";
//
//	char* ret = NULL;
//	for (ret = strtok(arr, p); ret != NULL; ret = strtok(NULL, p))
//	{
//		printf("%s\n", ret);
//	}
//
//	return 0;
//}

//======================================strerror(errno)=======================================
//strerror的作用是给相应错误码加上错误提示信息。errno是错误码，当有错误发生时，自动有一个值

//#include <errno.h>
//
//int main()
//{
//	FILE* pf = fopen("test.txt", "r");    //打开一个文件
//	if (pf == NULL)
//	{
//		printf("%s\n", strerror(errno));  //打不开
//	}
//	else
//	{
//		printf("open file success\n");    //打开了
//	}
//	return 0;
//}

//==================================字符分类函数，字符转换函数==============================
//字符分类，如果是这类返回真
//字符转换，转成另外的字符

//=====================================